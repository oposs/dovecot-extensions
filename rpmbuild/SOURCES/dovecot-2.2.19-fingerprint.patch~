diff --git a/README.md b/README.md
index b827443..1a069e5 100644
--- a/README.md
+++ b/README.md
@@ -2,3 +2,12 @@ dovecot-extensions
 ==================
 
 Extensions for dovecot
+
+Added Ceritificate and Certificate Checks to Dovecot 2.2.x
+
+- ssl_verify_depth:      will check the maximal certificate chain depth
+- ssl_cert_md_algorithm: will check the corresponding certificate fingerprint algorithm (md5/sha1/...)
+- cert_loginname:        will handle the loginname included in special client certificates (x509 fields)
+- cert_fingerprint:      allows to access the fingerprint of a certificate inbound of the dovecot (used for select and  compare with LDAP backend where the fingerprint of a user is stored)
+
+This patches are ported to dovecot-2.2.x from a patch serie done on Dovecot 2.0.16 done in 2011/2012
diff --git a/doc/example-config/conf.d/10-logging.conf b/doc/example-config/conf.d/10-logging.conf
index 14798f1..911568b 100644
--- a/doc/example-config/conf.d/10-logging.conf
+++ b/doc/example-config/conf.d/10-logging.conf
@@ -44,6 +44,12 @@
 # Show protocol level SSL errors.
 #verbose_ssl = no
 
+# Show additonal SSL client certificate information.
+#ssl_cert_info = no
+
+# Show additional SSL client certificate debug information.
+#ssl_cert_debug = no
+
 # mail_log plugin provides more event logging for mail processes.
 plugin {
   # Events to log. Also available: flag_change append
diff --git a/doc/example-config/conf.d/10-ssl.conf b/doc/example-config/conf.d/10-ssl.conf
index 31b750c..0ca8d9b 100644
--- a/doc/example-config/conf.d/10-ssl.conf
+++ b/doc/example-config/conf.d/10-ssl.conf
@@ -42,6 +42,13 @@ ssl_key = </etc/ssl/private/dovecot.pem
 # auth_ssl_username_from_cert=yes.
 #ssl_cert_username_field = commonName
 
+# Which fingerprint algorithm form a client certificate is used for verifing
+#ssl_cert_md_algorithm = sha1
+
+# Check the depth of a SSL certificate chain. The given value is the maximum
+# allowed depth. Default is 9.
+#ssl_verify_depth = 9
+
 # DH parameters length to use.
 #ssl_dh_parameters_length = 1024
 
diff --git a/doc/wiki/SSL.DovecotConfiguration.txt b/doc/wiki/SSL.DovecotConfiguration.txt
index 6e1e727..b3fe4f8 100644
--- a/doc/wiki/SSL.DovecotConfiguration.txt
+++ b/doc/wiki/SSL.DovecotConfiguration.txt
@@ -257,6 +257,19 @@ You may also force the username to be taken from the certificate by setting
    (parsed using OpenSSL's 'OBJ_txt2nid()' function). 'x500UniqueIdentifier' is
    a common choice.
 
+You may also configure the certificate algorithm. In that way valid and
+allowed client certificate can be looked up in a given database (SQL, LDAP).
+
+---%<-------------------------------------------------------------------------
+ssl_cert_md_algorithm = sha1
+---%<-------------------------------------------------------------------------
+
+The max. depth of the certificate chain can be configured:
+
+---%<-------------------------------------------------------------------------
+ssl_verify_depth = 3
+---%<-------------------------------------------------------------------------
+
 You may also want to disable the password checking completely. Doing this
 currently circumvents Dovecot's security model so it's not recommended to use
 it, but it is possible by making the <passdb> [PasswordDatabase.txt] allow
diff --git a/src/auth/auth-request-var-expand.c b/src/auth/auth-request-var-expand.c
index 11f78d3..d5d9070 100644
--- a/src/auth/auth-request-var-expand.c
+++ b/src/auth/auth-request-var-expand.c
@@ -42,6 +42,9 @@ auth_request_var_expand_static_tab[AUTH_REQUEST_VAR_TAB_COUNT+1] = {
 	{ '\0', NULL, "orig_user" },
 	{ '\0', NULL, "orig_username" },
 	{ '\0', NULL, "orig_domain" },
+        { 'z', NULL, "cert_loginname" },
+        { 'f', NULL, "cert_fingerprint" },
+        { 'F', NULL, "cert_fingerprint_base64" }, 
 	/* be sure to update AUTH_REQUEST_VAR_TAB_COUNT */
 	{ '\0', NULL, NULL }
 };
@@ -154,6 +157,15 @@ auth_request_get_var_expand_table_full(const struct auth_request *auth_request,
 	tab[29].value = strchr(orig_user, '@');
 	if (tab[29].value != NULL)
 		tab[29].value = escape_func(tab[29].value+1, auth_request);
+        if (auth_request->cert_loginname != NULL) {
+               tab[30].value = escape_func(auth_request->cert_loginname, auth_request);
+        }
+        if (auth_request->cert_fingerprint != NULL) {
+               tab[31].value = escape_func(auth_request->cert_fingerprint, auth_request);
+        }
+        if (auth_request->cert_fingerprint_base64 != NULL) {
+               tab[32].value = escape_func(auth_request->cert_fingerprint_base64, auth_request);
+        }
 	return ret_tab;
 }
 
diff --git a/src/auth/auth-request-var-expand.h b/src/auth/auth-request-var-expand.h
index 180454a..1362ec3 100644
--- a/src/auth/auth-request-var-expand.h
+++ b/src/auth/auth-request-var-expand.h
@@ -8,7 +8,7 @@ auth_request_escape_func_t(const char *string,
 #define AUTH_REQUEST_VAR_TAB_USER_IDX 0
 #define AUTH_REQUEST_VAR_TAB_USERNAME_IDX 1
 #define AUTH_REQUEST_VAR_TAB_DOMAIN_IDX 2
-#define AUTH_REQUEST_VAR_TAB_COUNT 30
+#define AUTH_REQUEST_VAR_TAB_COUNT 33
 extern const struct var_expand_table
 auth_request_var_expand_static_tab[AUTH_REQUEST_VAR_TAB_COUNT+1];
 
diff --git a/src/auth/auth-request.c b/src/auth/auth-request.c
index 6694bf9..91e817d 100644
--- a/src/auth/auth-request.c
+++ b/src/auth/auth-request.c
@@ -221,7 +221,6 @@ void auth_request_export(struct auth_request *request, string_t *dest)
 		auth_str_add_keyvalue(dest, "requested-login-user",
 				      request->requested_login_user);
 	}
-
 	if (request->local_ip.family != 0) {
 		auth_str_add_keyvalue(dest, "lip",
 				      net_ip2addr(&request->local_ip));
@@ -313,6 +312,12 @@ bool auth_request_import_auth(struct auth_request *request,
 		request->no_penalty = TRUE;
 	else if (strcmp(key, "valid-client-cert") == 0)
 		request->valid_client_cert = TRUE;
+	else if (strcmp(key, "cert_loginname") == 0)
+		request->cert_loginname = p_strdup(request->pool, value);
+	else if (strcmp(key, "cert_fingerprint") == 0)
+		request->cert_fingerprint = p_strdup(request->pool, value);
+	else if (strcmp(key, "cert_fingerprint_base64") == 0)
+		request->cert_fingerprint_base64 = p_strdup(request->pool, value);
 	else if (strcmp(key, "cert_username") == 0) {
 		if (request->set->ssl_username_from_cert) {
 			/* get username from SSL certificate. it overrides
@@ -620,6 +625,7 @@ auth_request_handle_passdb_callback(enum passdb_result *result,
 	} else {
 		next_passdb = request->passdb->next;
 	}
+
 	while (next_passdb != NULL &&
 	       auth_request_want_skip_passdb(request, next_passdb))
 		next_passdb = next_passdb->next;
diff --git a/src/auth/auth-request.h b/src/auth/auth-request.h
index e9dc0cd..897152e 100644
--- a/src/auth/auth-request.h
+++ b/src/auth/auth-request.h
@@ -26,14 +26,14 @@ struct auth_request {
 	int refcount;
 
 	pool_t pool;
-        enum auth_request_state state;
-        /* user contains the user who is being authenticated.
-           When master user is logging in as someone else, it gets more
-           complicated. Initially user is set to master's username and the
-           requested_login_user is set to destination username. After masterdb
-           has validated user as a valid master user, master_user is set to
-           user and user is set to requested_login_user. */
-        char *user, *requested_login_user, *master_user;
+	enum auth_request_state state;
+	/* user contains the user who is being authenticated.
+	   When master user is logging in as someone else, it gets more
+	   complicated. Initially user is set to master's username and the
+	   requested_login_user is set to destination username. After masterdb
+	   has validated user as a valid master user, master_user is set to
+	   user and user is set to requested_login_user. */
+	char *user, *requested_login_user, *master_user;
 	/* original_username contains the username exactly as given by the
 	   client. this is needed at least with DIGEST-MD5 for password
 	   verification. however with master logins the master username has
@@ -46,9 +46,13 @@ struct auth_request {
 	const char *realm;
 	char *mech_password; /* set if verify_plain() is called */
 	char *passdb_password; /* set after password lookup if successful */
-        /* extra_fields are returned in authentication reply. Fields prefixed
-           with "userdb_" are automatically placed to userdb_reply instead. */
-        struct auth_fields *extra_fields;
+	/* extra_fields are returned in authentication reply. Fields prefixed
+	   with "userdb_" are automatically placed to userdb_reply instead. */
+	/* the login/username and fingerprint given by the certificate */
+	char *cert_loginname;
+    char *cert_fingerprint;
+    char *cert_fingerprint_base64;
+	struct auth_fields *extra_fields;
 	/* the whole userdb result reply */
 	struct auth_fields *userdb_reply;
 	struct auth_request_proxy_dns_lookup_ctx *dns_lookup_ctx;
@@ -58,12 +62,12 @@ struct auth_request {
 
 	const struct mech_module *mech;
 	const struct auth_settings *set;
-        struct auth_passdb *passdb;
-        struct auth_userdb *userdb;
+	struct auth_passdb *passdb;
+	struct auth_userdb *userdb;
 
 	/* passdb lookups have a handler, userdb lookups don't */
 	struct auth_request_handler *handler;
-        struct auth_master_connection *master;
+	struct auth_master_connection *master;
 
 	unsigned int connect_uid;
 	unsigned int client_pid;
diff --git a/src/auth/db-checkpassword.c b/src/auth/db-checkpassword.c
index 5c47ffa..1062649 100644
--- a/src/auth/db-checkpassword.c
+++ b/src/auth/db-checkpassword.c
@@ -279,6 +279,18 @@ static void checkpassword_setup_env(struct auth_request *request)
 		env_put(t_strconcat("MASTER_USER=",
 				    request->master_user, NULL));
 	}
+	if (request->cert_loginname != NULL) {
+		env_put(t_strconcat("SSL_USERNAME_CONTENT=",
+					request->cert_loginname, NULL));
+	}
+	if (request->cert_fingerprint != NULL) {
+		env_put(t_strconcat("SSL_FINGERPRINT=",
+					request->cert_fingerprint, NULL));
+	}
+	if (request->cert_fingerprint_base64 != NULL) {
+		env_put(t_strconcat("SSL_FINGERPRINT_BASE64=",
+					request->cert_fingerprint_base64, NULL));
+	}
 	if (!auth_fields_is_empty(request->extra_fields)) {
 		const ARRAY_TYPE(auth_field) *fields =
 			auth_fields_export(request->extra_fields);
@@ -423,7 +435,7 @@ checkpassword_exec(struct db_checkpassword *db, struct auth_request *request,
 static void sigchld_handler(const struct child_wait_status *status,
 			    struct db_checkpassword *db)
 {
-	struct chkpw_auth_request *request = 
+	struct chkpw_auth_request *request =
 		hash_table_lookup(db->clients, POINTER_CAST(status->pid));
 
 	i_assert(request != NULL);
diff --git a/src/config/all-settings.c b/src/config/all-settings.c
index beef07b..d0ef7c8 100644
--- a/src/config/all-settings.c
+++ b/src/config/all-settings.c
@@ -280,6 +280,8 @@ struct master_service_ssl_settings {
 	const char *ssl_cipher_list;
 	const char *ssl_protocols;
 	const char *ssl_cert_username_field;
+	const char *ssl_cert_md_algorithm;
+	unsigned int ssl_verify_depth;
 	const char *ssl_crypto_device;
 	const char *ssl_options;
 
@@ -287,6 +289,8 @@ struct master_service_ssl_settings {
 	bool ssl_require_crl;
 	bool verbose_ssl;
 	bool ssl_prefer_server_ciphers;
+	bool ssl_cert_info;
+	bool ssl_cert_debug;
 
 	/* These are derived from ssl_options, not set directly */
 	struct {
diff --git a/src/imap-login/client.c b/src/imap-login/client.c
index fa7745f..8aeb19f 100644
--- a/src/imap-login/client.c
+++ b/src/imap-login/client.c
@@ -99,6 +99,7 @@ static const char *get_capability(struct client *client)
 	else {
 		str_append(cap_str, CAPABILITY_BANNER_STRING);
 		str_append_c(cap_str, ' ');
+		i_debug("CAP %s", imap_client->set->imap_capability);
 		str_append(cap_str, imap_client->set->imap_capability + 1);
 	}
 
@@ -122,6 +123,7 @@ static int cmd_capability(struct imap_client *imap_client)
 		imap_client->client_ignores_capability_resp_code = TRUE;
 	client_send_raw(client, t_strconcat(
 		"* CAPABILITY ", get_capability(client), "\r\n", NULL));
+	i_debug(t_strconcat("cmd_capability: fetched CAPABILITY ", get_capability(client), "\r\n", NULL));
 	client_send_reply(client, IMAP_CMD_REPLY_OK,
 		"Pre-login capabilities listed, post-login capabilities have more.");
 	return 1;
diff --git a/src/lib-auth/auth-client-request.c b/src/lib-auth/auth-client-request.c
index fe0b8ac..fad3cf6 100644
--- a/src/lib-auth/auth-client-request.c
+++ b/src/lib-auth/auth-client-request.c
@@ -51,6 +51,18 @@ static void auth_server_send_new_request(struct auth_server_connection *conn,
 		str_append(str, "\tcert_username=");
 		str_append_tabescaped(str, info->cert_username);
 	}
+	if (info->cert_loginname != NULL) {
+		str_append(str, "\tcert_loginname=");
+		str_append_tabescaped(str, info->cert_loginname);
+	}
+	if (info->cert_fingerprint != NULL) {
+		str_append(str, "\tcert_fingerprint=");
+		str_append_tabescaped(str, info->cert_fingerprint);
+	}
+	if (info->cert_fingerprint_base64 != NULL) {
+		str_append(str, "\tcert_fingerprint_base64=");
+		str_append_tabescaped(str, info->cert_fingerprint_base64);
+	}
 	if (info->local_ip.family != 0)
 		str_printfa(str, "\tlip=%s", net_ip2addr(&info->local_ip));
 	if (info->remote_ip.family != 0)
@@ -109,6 +121,12 @@ auth_client_request_new(struct auth_client *client,
 		p_strdup_empty(pool, request_info->session_id);
 	request->request_info.cert_username =
 		p_strdup_empty(pool, request_info->cert_username);
+	request->request_info.cert_loginname =
+		p_strdup(pool, request_info->cert_loginname);
+	request->request_info.cert_fingerprint =
+		p_strdup(pool, request_info->cert_fingerprint);
+	request->request_info.cert_fingerprint_base64 =
+		p_strdup(pool, request_info->cert_fingerprint_base64);
 	request->request_info.initial_resp_base64 =
 		p_strdup_empty(pool, request_info->initial_resp_base64);
 	
diff --git a/src/lib-auth/auth-client.h b/src/lib-auth/auth-client.h
index d4ec820..42cec03 100644
--- a/src/lib-auth/auth-client.h
+++ b/src/lib-auth/auth-client.h
@@ -39,6 +39,9 @@ struct auth_request_info {
 	const char *service;
 	const char *session_id;
 	const char *cert_username;
+	const char *cert_loginname;
+	const char *cert_fingerprint;
+	const char *cert_fingerprint_base64;
 	enum auth_request_flags flags;
 
 	struct ip_addr local_ip, remote_ip, real_local_ip, real_remote_ip;
diff --git a/src/lib-master/master-service-ssl-settings.c b/src/lib-master/master-service-ssl-settings.c
index 38a47a1..06b5bf6 100644
--- a/src/lib-master/master-service-ssl-settings.c
+++ b/src/lib-master/master-service-ssl-settings.c
@@ -24,10 +24,14 @@ static const struct setting_define master_service_ssl_setting_defines[] = {
 	DEF(SET_STR, ssl_protocols),
 	DEF(SET_STR, ssl_cert_username_field),
 	DEF(SET_STR, ssl_crypto_device),
+	DEF(SET_STR, ssl_cert_md_algorithm),
+	DEF(SET_UINT, ssl_verify_depth),
 	DEF(SET_BOOL, ssl_verify_client_cert),
 	DEF(SET_BOOL, ssl_require_crl),
 	DEF(SET_BOOL, verbose_ssl),
 	DEF(SET_BOOL, ssl_prefer_server_ciphers),
+	DEF(SET_BOOL, ssl_cert_info),
+	DEF(SET_BOOL, ssl_cert_debug),
 	DEF(SET_STR, ssl_options), /* parsed as a string to set bools */
 
 	SETTING_DEFINE_LIST_END
@@ -47,10 +51,14 @@ static const struct master_service_ssl_settings master_service_ssl_default_setti
 	.ssl_protocols = "!SSLv2",
 	.ssl_cert_username_field = "commonName",
 	.ssl_crypto_device = "",
+	.ssl_cert_md_algorithm = "sha1",
+	.ssl_verify_depth = 9,
 	.ssl_verify_client_cert = FALSE,
 	.ssl_require_crl = TRUE,
 	.verbose_ssl = FALSE,
 	.ssl_prefer_server_ciphers = FALSE,
+	.ssl_cert_info = FALSE,
+	.ssl_cert_debug = FALSE,
 	.ssl_options = "",
 };
 
diff --git a/src/lib-master/master-service-ssl-settings.h b/src/lib-master/master-service-ssl-settings.h
index fc37fbf..dda9881 100644
--- a/src/lib-master/master-service-ssl-settings.h
+++ b/src/lib-master/master-service-ssl-settings.h
@@ -13,12 +13,16 @@ struct master_service_ssl_settings {
 	const char *ssl_protocols;
 	const char *ssl_cert_username_field;
 	const char *ssl_crypto_device;
+	const char *ssl_cert_md_algorithm;
+	unsigned int ssl_verify_depth;
 	const char *ssl_options;
 
 	bool ssl_verify_client_cert;
 	bool ssl_require_crl;
 	bool verbose_ssl;
 	bool ssl_prefer_server_ciphers;
+	bool ssl_cert_info;
+	bool ssl_cert_debug;
 
 	/* These are derived from ssl_options, not set directly */
 	struct {
diff --git a/src/login-common/client-common-auth.c b/src/login-common/client-common-auth.c
index 90941c5..d51722f 100644
--- a/src/login-common/client-common-auth.c
+++ b/src/login-common/client-common-auth.c
@@ -105,6 +105,8 @@ static void client_auth_parse_args(struct client *client,
 			reply_r->destuser = value;
 		else if (strcmp(key, "pass") == 0)
 			reply_r->password = value;
+		else if (strcmp(key, "fingerprint") == 0)
+			reply_r->fingerprint = value;
 		else if (strcmp(key, "proxy_timeout") == 0) {
 			if (str_to_uint(value, &reply_r->proxy_timeout_msecs) < 0) {
 				i_error("BUG: Auth service returned invalid "
diff --git a/src/login-common/client-common.h b/src/login-common/client-common.h
index c4c8550..5c0f2b9 100644
--- a/src/login-common/client-common.h
+++ b/src/login-common/client-common.h
@@ -58,8 +58,9 @@ enum client_auth_result {
 struct client_auth_reply {
 	const char *master_user, *reason;
 	/* for proxying */
-	const char *host, *hostip, *source_ip;
+	const char *host, *hostip, *source_ip,;
 	const char *destuser, *password, *proxy_mech;
+	const char *fingerprint;
 	in_port_t port;
 	unsigned int proxy_timeout_msecs;
 	unsigned int proxy_refresh_secs;
diff --git a/src/login-common/login-settings.c b/src/login-common/login-settings.c
index 96eee10..83cc672 100644
--- a/src/login-common/login-settings.c
+++ b/src/login-common/login-settings.c
@@ -35,11 +35,17 @@ static const struct setting_define login_setting_defines[] = {
 	DEF(SET_BOOL, auth_ssl_require_client_cert),
 	DEF(SET_BOOL, auth_ssl_username_from_cert),
 
+	DEF(SET_STR, ssl_cert_md_algorithm),
+	DEF(SET_UINT, ssl_verify_depth),
+
 	DEF(SET_BOOL, disable_plaintext_auth),
 	DEF(SET_BOOL, auth_verbose),
 	DEF(SET_BOOL, auth_debug),
 	DEF(SET_BOOL, verbose_proctitle),
 
+	DEF(SET_BOOL, ssl_cert_info),
+	DEF(SET_BOOL, ssl_cert_debug),
+
 	DEF(SET_UINT, mail_max_userip_connections),
 
 	SETTING_DEFINE_LIST_END
@@ -61,12 +67,18 @@ static const struct login_settings login_default_settings = {
 	.auth_ssl_require_client_cert = FALSE,
 	.auth_ssl_username_from_cert = FALSE,
 
+	.ssl_cert_md_algorithm = "sha1",
+	.ssl_verify_depth = 9,
+
 	.disable_plaintext_auth = TRUE,
 	.auth_verbose = FALSE,
 	.auth_debug = FALSE,
 	.verbose_proctitle = FALSE,
 
-	.mail_max_userip_connections = 10
+	.mail_max_userip_connections = 10,
+
+	.ssl_cert_info = FALSE,
+	.ssl_cert_debug = FALSE
 };
 
 const struct setting_parser_info login_setting_parser_info = {
diff --git a/src/login-common/login-settings.h b/src/login-common/login-settings.h
index cc8e928..af7bd7b 100644
--- a/src/login-common/login-settings.h
+++ b/src/login-common/login-settings.h
@@ -18,12 +18,18 @@ struct login_settings {
 	bool auth_ssl_require_client_cert;
 	bool auth_ssl_username_from_cert;
 
+	const char* ssl_cert_md_algorithm;
+	unsigned int ssl_verify_depth;
+
 	bool disable_plaintext_auth;
 	bool auth_verbose;
 	bool auth_debug;
 	bool auth_debug_passwords;
 	bool verbose_proctitle;
 
+	bool ssl_cert_info;
+	bool ssl_cert_debug;
+
 	unsigned int mail_max_userip_connections;
 
 	/* generated: */
diff --git a/src/login-common/sasl-server.c b/src/login-common/sasl-server.c
index 9f3c530..a496c01 100644
--- a/src/login-common/sasl-server.c
+++ b/src/login-common/sasl-server.c
@@ -349,6 +349,12 @@ void sasl_server_auth_begin(struct client *client,
 	info.session_id = client_get_session_id(client);
 	info.cert_username = client->ssl_proxy == NULL ? NULL :
 		ssl_proxy_get_peer_name(client->ssl_proxy);
+	info.cert_loginname = client->ssl_proxy == NULL ? NULL :
+		ssl_proxy_get_peer_name(client->ssl_proxy);
+	info.cert_fingerprint = client->ssl_proxy == NULL ? NULL :
+		ssl_proxy_get_fingerprint(client->ssl_proxy);
+	info.cert_fingerprint_base64 = client->ssl_proxy == NULL ? NULL :
+		ssl_proxy_get_fingerprint_base64(client->ssl_proxy);
 	info.flags = client_get_auth_flags(client);
 	info.local_ip = client->local_ip;
 	info.remote_ip = client->ip;
diff --git a/src/login-common/ssl-proxy-gnutls.c b/src/login-common/ssl-proxy-gnutls.c
index 2f73f81..6dab67b 100644
--- a/src/login-common/ssl-proxy-gnutls.c
+++ b/src/login-common/ssl-proxy-gnutls.c
@@ -60,6 +60,16 @@ static const char *get_alert_text(struct ssl_proxy *proxy)
 	return gnutls_alert_get_name(gnutls_alert_get(proxy->session));
 }
 
+const char *ssl_proxy_get_fingerprint(struct ssl_proxy *proxy __attr_unused__)
+{
+	return NULL;
+}
+
+const char *ssl_proxy_get_fingerprint_base64(struct ssl_proxy *proxy __attr_unused__)
+{
+	return NULL;
+}
+
 static int handle_ssl_error(struct ssl_proxy *proxy, int error)
 {
 	if (!gnutls_error_is_fatal(error)) {
diff --git a/src/login-common/ssl-proxy-openssl.c b/src/login-common/ssl-proxy-openssl.c
index cf6a36a..46d6df6 100644
--- a/src/login-common/ssl-proxy-openssl.c
+++ b/src/login-common/ssl-proxy-openssl.c
@@ -42,6 +42,8 @@
 #  undef HAVE_SSL_GET_SERVERNAME
 #endif
 
+static const char hexcodes[] = "0123456789ABCDEF";
+
 enum ssl_io_action {
 	SSL_ADD_INPUT,
 	SSL_REMOVE_INPUT,
@@ -100,6 +102,7 @@ struct ssl_server_context {
 	const char *ca;
 	const char *cipher_list;
 	const char *protocols;
+	unsigned int verify_depth;
 	bool verify_client_cert;
 	bool prefer_server_ciphers;
 	bool compression;
@@ -167,10 +170,17 @@ static int ssl_server_context_cmp(const struct ssl_server_context *ctx1,
 		return 1;
 	if (null_strcmp(ctx1->protocols, ctx2->protocols) != 0)
 		return 1;
+	if (ctx1->verify_depth != ctx2->verify_depth)
+		return 1;
+	if (ctx1->verify_client_cert != ctx2->verify_client_cert)
+		return 1;
+
+    return 0;
 
-	return ctx1->verify_client_cert == ctx2->verify_client_cert ? 0 : 1;
 }
 
+
+
 static void ssl_params_corrupted(const char *reason)
 {
 	i_fatal("Corrupted SSL ssl-parameters.dat in state_dir: %s", reason);
@@ -643,6 +653,7 @@ ssl_server_context_get(const struct login_settings *login_set,
 	lookup_ctx.key = set->ssl_key;
 	lookup_ctx.ca = set->ssl_ca;
 	lookup_ctx.cipher_list = set->ssl_cipher_list;
+	lookup_ctx.verify_depth = set->ssl_verify_depth;
 	lookup_ctx.protocols = set->ssl_protocols;
 	lookup_ctx.verify_client_cert = set->ssl_verify_client_cert ||
 		login_set->auth_ssl_require_client_cert ||
@@ -744,7 +755,10 @@ const char *ssl_proxy_get_peer_name(struct ssl_proxy *proxy)
 		}
 	}
 	X509_free(x509);
-	
+
+	if (proxy->ssl_set->ssl_cert_info)
+		i_info("x509 name found in certificate \"%s\" ...", name);
+
 	return *name == '\0' ? NULL : name;
 }
 
@@ -1229,7 +1243,7 @@ ssl_proxy_ctx_use_certificate_chain(SSL_CTX *ctx, const char *cert)
 		X509 *ca;
 		int r;
 		unsigned long err;
-		
+
 		while ((ca = PEM_read_bio_X509(in,NULL,NULL,NULL)) != NULL) {
 			r = SSL_CTX_add_extra_chain_cert(ctx, ca);
 			if (!r) {
@@ -1242,7 +1256,7 @@ ssl_proxy_ctx_use_certificate_chain(SSL_CTX *ctx, const char *cert)
 		err = ERR_peek_last_error();
 		if (ERR_GET_LIB(err) == ERR_LIB_PEM && ERR_GET_REASON(err) == PEM_R_NO_START_LINE)
 			ERR_clear_error();
-		else 
+		else
 			ret = 0; /* some real error */
 		}
 
@@ -1295,6 +1309,7 @@ ssl_server_context_init(const struct login_settings *login_set,
 	ctx->key = p_strdup(pool, ssl_set->ssl_key);
 	ctx->ca = p_strdup(pool, ssl_set->ssl_ca);
 	ctx->cipher_list = p_strdup(pool, ssl_set->ssl_cipher_list);
+	ctx->verify_depth = ssl_set->ssl_verify_depth;
 	ctx->protocols = p_strdup(pool, ssl_set->ssl_protocols);
 	ctx->verify_client_cert = ssl_set->ssl_verify_client_cert ||
 		login_set->auth_ssl_require_client_cert ||
@@ -1307,6 +1322,17 @@ ssl_server_context_init(const struct login_settings *login_set,
 		i_fatal("SSL_CTX_new() failed");
 	xnames = ssl_proxy_ctx_init(ssl_ctx, ssl_set, ctx->verify_client_cert);
 
+	/* 	Note: we add one to the configured depth purposefully.  As noted
+		in the OpenSSL man pages, the verification process will silently
+		stop at the configured depth, and the error messages ensuing will
+		be that of an incomplete certificate chain, rather than the
+		"chain too long" error that might be expected. To log the "chain
+		too long" condition, we add one to the configured depth, and catch,
+		in the verify callback, the exceeding of the actual depth.
+	*/
+
+    SSL_CTX_set_verify_depth(ssl_ctx, ctx->verify_depth + 1);
+
 	if (SSL_CTX_set_cipher_list(ssl_ctx, ctx->cipher_list) != 1) {
 		i_fatal("Can't set cipher list to '%s': %s",
 			ctx->cipher_list, ssl_last_error());
@@ -1463,4 +1489,134 @@ void ssl_proxy_deinit(void)
 	ERR_free_strings();
 }
 
+const char *ssl_proxy_get_fingerprint(struct ssl_proxy *proxy)
+{
+    return __ssl_proxy_get_fingerprint(proxy, 0);
+}
+
+const char *ssl_proxy_get_fingerprint_base64(struct ssl_proxy *proxy)
+{
+	return __ssl_proxy_get_fingerprint(proxy, 1);
+}
+
+const char *__ssl_proxy_get_fingerprint(struct ssl_proxy *proxy, bool base64mode)
+{
+    X509 *x509;
+    char *peer_fingerprint = NULL;
+    char *ssl_cert_md_algorithm = NULL;
+    const EVP_MD *md_alg;
+    unsigned char md_buf[EVP_MAX_MD_SIZE];
+    unsigned int md_len;
+    int j;
+
+    /* begin base64: needed for base64 handling */
+    char *fingerprint_ascii_ptr = NULL;
+    char arr[21];
+    int index = 0;
+    int num = 0;
+    /* end base64 */
+
+    if (!ssl_proxy_has_valid_client_cert(proxy))
+        return NULL;
+
+    x509 = SSL_get_peer_certificate(proxy->ssl);
+    if (x509 == NULL)
+        return NULL; /* we should have had it.. */
+
+    ssl_cert_md_algorithm = t_strdup_printf("%s", proxy->ssl_set->ssl_cert_md_algorithm);
+
+    if ((md_alg = EVP_get_digestbyname(ssl_cert_md_algorithm)) == 0) {
+        i_panic("Certificate digest algorithm \"%s\" not found ...",
+                ssl_cert_md_algorithm);
+    }
+
+    /* Fails when serialization to ASN.1 runs out of memory */
+    if (X509_digest(x509, md_alg, md_buf, &md_len) == 0) {
+        i_fatal("Certificate error computing certificate %s digest (out of memory?)",
+                ssl_cert_md_algorithm);
+    }
+
+    /* Check for OpenSSL contract violation */
+    if (md_len > EVP_MAX_MD_SIZE || md_len >= INT_MAX / 3)
+        i_panic("unexpectedly large %s digest size: %u",
+                ssl_cert_md_algorithm, md_len);
+
+    peer_fingerprint = i_malloc(md_len * 3);
+
+    for (j = 0; j < (int) md_len; j++) {
+        if (!base64mode) {
+            peer_fingerprint[j * 3] = hexcodes[(md_buf[j] & 0xf0) >> 4U];
+            peer_fingerprint[(j * 3) + 1] = hexcodes[(md_buf[j] & 0x0f)];
+            if (j + 1 != (int) md_len) {
+                peer_fingerprint[(j * 3) + 2] = ':';
+            } else {
+                peer_fingerprint[(j * 3) + 2] = '\0';
+            }
+        } else {
+            peer_fingerprint[j * 2] = hexcodes[(md_buf[j] & 0xf0) >> 4U];
+            peer_fingerprint[(j * 2) + 1] = hexcodes[(md_buf[j] & 0x0f)];
+        }
+
+        if (proxy->ssl_set->ssl_cert_debug) {
+            if (!base64mode) {
+                i_debug("fingerprint: %s", peer_fingerprint);
+            } else {
+                i_debug("fingerprint_compressed: %s", peer_fingerprint);
+            }
+        }
+    }
+
+    if (proxy->ssl_set->ssl_cert_info) {
+        if (!base64mode) {
+            i_info("x509 fingerprint found: %s", peer_fingerprint);
+        } else {
+            i_info("x509 fingerprint_compressed found: %s", peer_fingerprint);
+        }
+    }
+
+    if (base64mode) {
+        fingerprint_ascii_ptr   = peer_fingerprint;
+        /* convert hex to int array */
+        while(sscanf(fingerprint_ascii_ptr,"%02x",&num) == 1){
+            fingerprint_ascii_ptr += 2;
+            arr[index] = num;
+            index++;
+            if (proxy->ssl_set->ssl_cert_debug) {
+                i_debug("fingerprint_binary: %s", arr);
+            }
+        }
+        if (proxy->ssl_set->ssl_cert_debug) {
+            i_debug("x509 fingerprint_binary: %s", arr);
+        }
+        i_free(peer_fingerprint);
+        return (const char *)__base64(arr, index);
+    }
+
+    /* non base64 case */
+    return (const char *)peer_fingerprint;
+}
+
+char *__base64(const char *input, int length)
+{
+    char *buff;
+
+    BIO *bmem, *b64;
+    BUF_MEM *bptr;
+
+    b64 = BIO_new(BIO_f_base64());
+    bmem = BIO_new(BIO_s_mem());
+    b64 = BIO_push(b64, bmem);
+    BIO_write(b64, input, length);
+    BIO_flush(b64);
+    BIO_get_mem_ptr(b64, &bptr);
+
+    buff = i_malloc(bptr->length);
+    memcpy(buff, bptr->data, bptr->length-1);
+    buff[bptr->length-1] = 0;
+
+    BIO_free_all(b64);
+
+    return buff;
+}
+
 #endif
diff --git a/src/login-common/ssl-proxy.c b/src/login-common/ssl-proxy.c
index bec9434..2147317 100644
--- a/src/login-common/ssl-proxy.c
+++ b/src/login-common/ssl-proxy.c
@@ -90,6 +90,16 @@ void ssl_proxy_destroy(struct ssl_proxy *proxy ATTR_UNUSED) {}
 
 void ssl_proxy_free(struct ssl_proxy **proxy ATTR_UNUSED) {}
 
+const char *ssl_proxy_get_fingerprint(struct ssl_proxy *proxy __attr_unused__)
+{
+	return NULL;
+}
+
+const char *ssl_proxy_get_fingerprint_base64(struct ssl_proxy *proxy __attr_unused__)
+{
+	return NULL;
+}
+
 unsigned int ssl_proxy_get_count(void)
 {
 	return 0;
diff --git a/src/login-common/ssl-proxy.h b/src/login-common/ssl-proxy.h
index 2cb79cb..b2d4b40 100644
--- a/src/login-common/ssl-proxy.h
+++ b/src/login-common/ssl-proxy.h
@@ -43,4 +43,9 @@ unsigned int ssl_proxy_get_count(void) ATTR_PURE;
 void ssl_proxy_init(void);
 void ssl_proxy_deinit(void);
 
+const char *ssl_proxy_get_fingerprint(struct ssl_proxy *proxy);
+const char *ssl_proxy_get_fingerprint_base64(struct ssl_proxy *proxy);
+const char *__ssl_proxy_get_fingerprint(struct ssl_proxy *proxy, bool base64mode);
+char *__base64(const char *input, int length);
+
 #endif
